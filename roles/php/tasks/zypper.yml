---
# zypper related OS tasks

- name: install needed php packages
  zypper:
    name: "{{ php_package_required }}"
    state: latest

- name: install optional php packages
  zypper:
    name: "{{ php_package_optional }}"
    state: latest
  when: php_install_optional_packages|bool

- name: configure php postgres module
  copy:
    dest: /etc/php{{ php_version.split('.')[0] }}/conf.d/pgsql.ini
    content: |
      # configuration for PHP PostgreSQL module
      extension=pgsql.so

      [PostgresSQL]
      pgsql.allow_persistent = On
      pgsql.auto_reset_persistent = Off
      pgsql.max_persistent = -1
      pgsql.max_links = -1
      pgsql.ignore_notice = 0
      pgsql.log_notice = 0
    owner: root
    group: root
    mode: 0644
    backup: true
  when: nextcloud_db_type == 'pgsql'
  notify: restart web services

- name: configure php mysql module
  copy:
    dest: /etc/php{{ php_version.split('.')[0] }}/conf.d/pdo_mysql.ini
    content: |
      # configuration for PHP MySQL module
      extension=pdo_mysql.so

      [mysql]
      mysql.allow_local_infile=On
      mysql.allow_persistent=On
      mysql.cache_size=2000
      mysql.max_persistent=-1
      mysql.max_links=-1
      mysql.default_port=
      mysql.default_socket=/var/lib/mysql/mysql.sock
      mysql.default_host=
      mysql.default_user=
      mysql.default_password=
      mysql.connect_timeout=60
      mysql.trace_mode=Off
    owner: root
    group: root
    mode: 0644
    backup: true
  when: nextcloud_db_type == 'mysql'
  notify: restart web services

- name: configure php apcu module
  copy:
    dest: /etc/php{{ php_version.split('.')[0] }}/conf.d/apcu.ini
    content: |
      extension=apcu.so
      apc.enable_cli=1
    owner: root
    group: root
    mode: 0644
    backup: true

# - name: open redis port if remote server
  # ufw:
    # rule: allow
    # port: "{{ redis_tcp.port|int }}"
    # proto: tcp
  # when: groups['redis'][0] != groups['webserver'][0]
  # delegate_to: redis

# TBD: Testing needed
- name: open redis port if remote server
  block:
    - name: open firewall ports
      firewalld:
        port: "{{ item }}"
        permanent: true
        immediate: false
        state: enabled
      loop:
        - "{{ redis_tcp.port|int }}/tcp"
      vars:
        ansible_python_interpreter: python3
  when: groups['redis'][0] != groups['webserver'][0]
  delegate_to: redis

# No restart of service or machine required when removing a profile from apparmor.
# When adding the profile again to apparmor ( rm -rf /etc/apparmor.d/disable/php-fpm && apparmor_parser -a /etc/apparmor.d/php-fpm) then "systemctl restart php-fpm.service" is required
# When the following three tasks are not executed, you can monitor with
# tail -f /var/log/audit/audit.log | grep --line-buffered DENIED
# if the apparmor profile is triggered, when loading the nextcloud web page in a browser
# In parallel you can use 
# tail -f /var/log/nginx/error.log
# to see the "Permission denied in Unknown on line 0Unable to open primary script" error.
# TBD: Modify the apparmor profile instead of deactivating it?!
- name: Check if apparmor php-fpm profile is disabled
  stat:
    path: /etc/apparmor.d/disable/php-fpm
  register: stat_result

- name: Unload apparmor php-fpm profile because of problems for nginx to access the php socket
  command: apparmor_parser -R /etc/apparmor.d/php-fpm
  when: not stat_result.stat.exists

- name: Create a symbolic link to disable apparmor php-fpm profile
  ansible.builtin.file:
    src: /etc/apparmor.d/php-fpm
    dest: /etc/apparmor.d/disable/php-fpm
    state: link
  when: not stat_result.stat.exists